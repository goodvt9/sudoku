<!doctype html>
<html lang="zh-Hant">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>æ•¸ç¨ï½œæ¡Œæ©Ÿ/æ‰‹æ©Ÿé›™å„ªåŒ–ï¼‹éŒ¯èª¤è­¦å‘Šï¼‹å®Œæˆåµæ¸¬ï¼ˆæ‰‹æ©Ÿç¦æ­¢å·¦å³æ»‘ï½œcellè‡ªå‹•ç¸®æ”¾ï¼‰</title>

  <style>
    *{ box-sizing:border-box; }
    html, body { height: 100%; }

    :root{
      --cell: 44px;              /* âœ… æœƒè¢« JS åœ¨æ‰‹æ©Ÿç«¯è‡ªå‹•èª¿æ•´ */
      --thin: 1px;
      --thick: 3px;
      --line: #111;

      --card: #fff;
      --page: #f6f6f6;
      --dash: #d2d2d2;

      --radius: 14px;
      --gap: 16px;

      --sidebarW: 320px;
      --mobileBarH: 330px;       /* âœ… æ‰‹æ©Ÿåº•éƒ¨å·¥å…·åˆ—é«˜åº¦ï¼ˆæœ¬ç‰ˆå¤šä¸€æ’æŒ‰éˆ•ï¼‰ */
      --safeBottom: env(safe-area-inset-bottom, 0px);
    }

    html.is-mobile{ }

    body{
      margin: 20px;
      background: var(--page);
      color: #111;
      font-family: system-ui, -apple-system, "Segoe UI", Roboto, "Noto Sans TC", Arial, sans-serif;
    }
    html.is-mobile body{ margin: 14px; }

    .wrap{
      max-width: 1250px;
      margin: 0 auto;
      display: grid;
      gap: var(--gap);
    }

    /* âœ… æ‰‹æ©Ÿæœ‰åº•éƒ¨å·¥å…·åˆ—ï¼šç•™ç™½é¿å…é®æ“‹ */
    html.is-mobile .wrap{
      padding-bottom: calc(var(--mobileBarH) + var(--safeBottom) + 12px);
    }

    /* ===== éŒ¯èª¤é¡¯ç¤ºæ¢ï¼ˆJS æœ‰éŒ¯ä½ ç«‹åˆ»çœ‹åˆ°ï¼‰ ===== */
    .errbar{
      display:none;
      background: #ffecec;
      border: 1px solid #ffb4b4;
      color: #7a0010;
      border-radius: 12px;
      padding: 10px 12px;
      font-size: 13px;
      line-height: 1.45;
      white-space: pre-wrap;
    }
    .errbar.show{ display:block; }

    .panel{
      background: var(--card);
      border: 1px solid #e6e6e6;
      border-radius: var(--radius);
      padding: 14px 16px;
      display: grid;
      gap: 10px;
    }
    .panel h1{ font-size: 18px; margin: 0; letter-spacing: .4px; }

    .controls{
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 10px;
    }
    label{
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-size: 14px;
      color: #333;
    }
    input[type="number"]{
      width: 90px;
      padding: 8px 10px;
      border: 1px solid #d9d9d9;
      border-radius: 10px;
      font-size: 14px;
      outline: none;
      background: #fff;
    }
    input[type="number"]:focus{ border-color:#999; }
    input[type="number"]:disabled{
      opacity: .55;
      cursor: not-allowed;
      background: #f5f5f5;
    }
    button{
      padding: 9px 12px;
      border: 1px solid #d9d9d9;
      border-radius: 10px;
      background: #fff;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover{ border-color:#999; }
    button:disabled{ opacity:.5; cursor:not-allowed; }

    .hint{
      font-size: 12px;
      color: #666;
      line-height: 1.55;
      margin: 0;
    }

    /* âœ… æ‰‹æ©Ÿï¼šéš±è—ç´…è‰²å€å¡Šï¼ˆä¸Šæ–¹è¨­å®š panel å…¨éƒ¨éš±è—ï¼‰ */
    html.is-mobile .panel{
      display: none !important;
    }

    /* ===== ä¸»è¦å¸ƒå±€ï¼šæ¡Œæ©Ÿå…©æ¬„ï¼›æ‰‹æ©Ÿå–®æ¬„ï¼ˆCSS fallbackï¼‰ ===== */
    .layout{
      display: grid;
      grid-template-columns: 1fr var(--sidebarW);
      gap: var(--gap);
      align-items: start;
    }

    @media (max-width: 980px){
      .layout{ grid-template-columns: 1fr; }
      .sidebar{ display:none !important; }
    }
    @media (pointer: coarse){
      @media (max-width: 1100px){
        .layout{ grid-template-columns: 1fr; }
        .sidebar{ display:none !important; }
      }
    }

    /* å³å´å·¥å…·åˆ—ï¼ˆæ¡Œæ©Ÿï¼‰ */
    .sidebar{
      position: sticky;
      top: 16px;
      align-self: start;
      background: var(--card);
      border: 1px solid #e6e6e6;
      border-radius: var(--radius);
      padding: 12px;
      display: grid;
      gap: 10px;
      box-shadow: 0 2px 10px rgba(0,0,0,.04);
    }

    .side-title{
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .side-title h3{ margin: 0; font-size: 14px; letter-spacing: .2px; }
    .pill{
      font-size: 12px;
      padding: 2px 8px;
      border-radius: 999px;
      background: #f1f1f1;
      color: #444;
      white-space: nowrap;
    }
    .side-status{
      font-size: 12px;
      color: #666;
      line-height: 1.45;
      min-height: 34px;
      padding: 8px 10px;
      border: 1px dashed var(--dash);
      border-radius: 12px;
      background: #fafafa;
    }
    .toggles{ display: flex; flex-wrap: wrap; gap: 8px; }
    .toggle-on{ border-color: #111; font-weight: 800; }

    .keypad{
      display: grid;
      grid-template-columns: repeat(5, minmax(0, 1fr));
      gap: 8px;
    }
    .keypad button{
      padding: 12px 0;
      border-radius: 12px;
      font-weight: 900;
      font-size: 15px;
    }
    .keypad .wide{ grid-column: span 2; }

    .actions{
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
    }
    .actions button{
      padding: 10px 10px;
      border-radius: 12px;
      font-weight: 750;
      font-size: 13px;
    }

    /* ===== é¡Œç›®å€ ===== */
    .days{
      display: grid;
      gap: var(--gap);

      --board: calc(44px * 9 + var(--thick) * 2);
      --card-min: calc(var(--board) + 28px + 8px);

      grid-template-columns: repeat(auto-fit, minmax(var(--card-min), 1fr));
      align-items: start;
    }
    @media (max-width: 980px){
      .days{ grid-template-columns: 1fr; }
    }

    .card{
      background: var(--card);
      border: 1px solid #e6e6e6;
      border-radius: var(--radius);
      padding: 14px 14px 12px;
      box-shadow: 0 2px 10px rgba(0,0,0,.04);
      overflow: visible;
      display: grid;
      gap: 10px;
    }

    .card.active{
      border-color: #111;
      box-shadow: 0 6px 16px rgba(0,0,0,.08);
    }
    .card.completed{
      border-color: #1b5e20;
      box-shadow: 0 6px 18px rgba(27,94,32,.22);
    }
    .card.completed h2::after{
      content: " âœ” å®Œæˆ";
      color: #1b5e20;
      font-weight: 900;
      margin-left: 6px;
    }

    .card h2{
      margin: 0;
      font-size: 15px;
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      gap: 10px;
    }
    .badge{
      font-size: 12px;
      color: #444;
      background: #f1f1f1;
      padding: 2px 8px;
      border-radius: 999px;
      white-space: nowrap;
    }
    .divider{
      margin-top: 6px;
      border-top: 2px dashed var(--dash);
      height: 0;
      width: 100%;
    }

    /* ===== Sudokuï¼ˆå›ºå®šç›¤é¢å¯¬ï¼‰ ===== */
    .sudoku{
      --boardW: calc(var(--cell) * 9 + var(--thick) * 2);

      width: var(--boardW);
      margin: 0 auto;

      display: grid;
      grid-template-columns: repeat(9, var(--cell));
      grid-template-rows: repeat(9, var(--cell));

      border: var(--thick) solid var(--line);
      border-radius: 10px;

      overflow: visible;
      user-select: none;
    }

    .cell{
      position: relative;
      display: grid;
      place-items: center;

      width: var(--cell);
      height: var(--cell);
      min-width: var(--cell);
      min-height: var(--cell);

      border-right: var(--thin) solid var(--line);
      border-bottom: var(--thin) solid var(--line);

      font-size: 18px;
      font-weight: 650;
      background: #fff;
      line-height: 1;
      cursor: pointer;
      outline: none;
    }
    .cell:focus{ outline: 2px solid #000; outline-offset: -2px; }

    .cell.thick-r{ border-right: var(--thick) solid var(--line); }
    .cell.thick-b{ border-bottom: var(--thick) solid var(--line); }
    .cell.last-col{ border-right: 0; }
    .cell.last-row{ border-bottom: 0; }

    .cell.given{ cursor: default; }
    .cell.selected{ background: #f3f3f3; }
    .cell.user{ color: #0b57d0; font-weight: 780; }
    .cell.wrong{ background: #ffecec; color: #b00020 !important; font-weight: 900; }
    .cell.solved{ color: #146c43; font-weight: 900; }

    .notes{
      position: absolute;
      inset: 3px;
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      grid-template-rows: repeat(3, 1fr);
      font-size: 10px;
      font-weight: 700;
      color: #777;
      line-height: 1;
      pointer-events: none;
      text-align: center;
      align-items: center;
      justify-items: center;
    }

    /* ===== æ‰‹æ©Ÿåº•éƒ¨å·¥å…·åˆ— ===== */
    .mobilebar{ display:none; }

    html.is-mobile .mobilebar{
      display: grid;
      position: fixed;
      left: 12px;
      right: 12px;
      bottom: calc(12px + var(--safeBottom));
      z-index: 999;
      background: rgba(255,255,255,.96);
      border: 1px solid #e2e2e2;
      border-radius: 16px;
      padding: 10px;
      box-shadow: 0 12px 30px rgba(0,0,0,.14);
      backdrop-filter: blur(6px);
      gap: 10px;
    }

    .mobile-status{
      font-size: 12px;
      color: #666;
      line-height: 1.35;
      padding: 8px 10px;
      border: 1px dashed var(--dash);
      border-radius: 12px;
      background: #fafafa;
      min-height: 34px;
    }

    .mobile-row{
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      justify-content: center;
    }
    .mobile-row button{
      padding: 10px 10px;
      border-radius: 12px;
      font-weight: 800;
      font-size: 13px;
      flex: 1 1 auto;
    }

    html.is-mobile .mobilebar .keypad{
      grid-template-columns: repeat(6, minmax(0, 1fr));
    }
    html.is-mobile .mobilebar .keypad button{
      padding: 14px 0;
      font-size: 16px;
      border-radius: 14px;
    }

    /* âœ… æ‰‹æ©Ÿï¼šç¦æ­¢å·¦å³æ»‘å‹•ï¼ˆä¸ä½¿ç”¨ transformï¼‰ */
    html.is-mobile .card{
      overflow-x: hidden;
      overflow-y: visible;
    }
    html.is-mobile .board-wrap{
      width: 100%;
      display: grid;
      place-items: center;
      overflow: hidden;
    }
    html.is-mobile .sudoku{
      transform: none !important;
    }

    @media print{
      body{ background: #fff; margin: 10mm; }
      .hint{ display: none; }
      .sidebar, .mobilebar, .panel{ display: none !important; }
      .card{ box-shadow: none; }
    }
  </style>
</head>

<body>
  <div class="wrap">
    <div id="errbar" class="errbar"></div>

    <!-- âœ… æ¡Œæ©Ÿè¨­å®šï¼ˆæ‰‹æ©Ÿæœƒéš±è—ï¼‰ -->
    <section class="panel">
      <h1>æ•¸ç¨æ¯æ—¥é¡Œç›®ï¼ˆæ¡Œæ©Ÿ/æ‰‹æ©Ÿé›™å„ªåŒ–ï¼‹å®Œæˆåµæ¸¬ï½œæ‰‹æ©Ÿç¦æ­¢å·¦å³æ»‘ï½œcell è‡ªå‹•ç¸®æ”¾ï¼‰</h1>

      <div class="controls">
        <label>å¹¾å¤©ï¼ˆå¹¾é¡Œï¼‰
          <input id="days" type="number" min="1" max="60" value="30" />
        </label>

        <label>æ ¼å­å¤§å°
          <input id="cellSize" type="number" min="28" max="64" value="44" />
        </label>

        <button id="regen">é‡æ–°ç”¢ç”Ÿ</button>
      </div>

      <p class="hint">
        æ“ä½œï¼šé»ç©ºæ ¼ â†’ ç”¨å³å´ï¼ˆæ¡Œæ©Ÿï¼‰æˆ–åº•éƒ¨ï¼ˆæ‰‹æ©Ÿï¼‰æ•¸å­—é¢æ¿è¼¸å…¥ã€‚<br/>
        æ‰‹æ©Ÿ/å¹³æ¿å›ºå®šã€Œ1 é¡Œæ¨¡å¼ã€ï¼Œæ¡Œæ©Ÿå¯å¤šé¡Œå¤šæ¬„ã€‚éŒ¯èª¤è­¦å‘Šå¯ä¸­é€”é–‹é—œå³æ™‚åµæ¸¬ï¼›è§£å®Œæœƒå®Œæˆåµæ¸¬ä¸¦é–ç›¤ï¼ˆå¯é‡ç½®ï¼‰ã€‚<br/>
        âœ… æ‰‹æ©Ÿç›¤é¢æœƒè‡ªå‹•æŠŠæ ¼å­ç¸®åˆ°å‰›å¥½å¡é€²ç•«é¢ï¼šç¦æ­¢å·¦å³æ»‘ï¼Œé¿å…å³å´è¢«åˆ‡ã€‚
      </p>
    </section>

    <section class="layout">
      <section id="daysWrap" class="days"></section>

      <!-- æ¡Œæ©Ÿå³å´å·¥å…·åˆ— -->
      <aside class="sidebar" aria-label="æ¡Œæ©Ÿå·¥å…·åˆ—">
        <div class="side-title">
          <h3>å·¥å…·åˆ—</h3>
          <span id="activeLabel" class="pill">å°šæœªé¸é¡Œ</span>
        </div>

        <div id="sideStatus" class="side-status">å…ˆé»ä»»ä¸€é¡Œçš„ç©ºæ ¼é–‹å§‹ã€‚</div>



        <div class="toggles">
          <button id="btnNote" type="button">ç­†è¨˜ï¼šOFF</button>
          <button id="btnWarn" type="button">éŒ¯èª¤è­¦å‘Šï¼šOFF</button>
        </div>

        <div class="keypad" aria-label="æ•¸å­—é¢æ¿">
          <button data-k="1">1</button><button data-k="2">2</button><button data-k="3">3</button><button data-k="4">4</button><button data-k="5">5</button>
          <button data-k="6">6</button><button data-k="7">7</button><button data-k="8">8</button><button data-k="9">9</button>
          <button class="wide" data-act="clear">æ¸…é™¤</button>
          <button class="wide" data-act="hint">æç¤º 1 æ ¼</button>
        </div>

        <div class="actions">
          <button data-act="solve">é¡¯ç¤ºç­”æ¡ˆ</button>
          <button data-act="reset">é‡ç½®æœ¬é¡Œ</button>
        </div>
      </aside>
    </section>
  </div>

  <!-- âœ… æ‰‹æ©Ÿåº•éƒ¨å·¥å…·åˆ—ï¼ˆæ–°å¢ é‡æ–°ç”¢ç”Ÿ æŒ‰éˆ•ï¼‰ -->
  <section class="mobilebar" aria-label="æ‰‹æ©Ÿå·¥å…·åˆ—">
    <div id="mobileStatus" class="mobile-status">å…ˆé»ç©ºæ ¼é–‹å§‹ã€‚</div>

    <div class="mobile-row">
      <button id="mBtnNote" type="button">ç­†è¨˜ï¼šOFF</button>
      <button id="mBtnWarn" type="button">éŒ¯èª¤è­¦å‘Šï¼šOFF</button>
      <button id="mBtnClear" type="button">æ¸…é™¤</button>
    </div>

    <!-- âœ… è—è‰²å€å¡Šï¼šæŠŠé‡æ–°ç”¢ç”ŸåŠŸèƒ½æ¬åˆ°é€™è£¡ -->
    <div class="mobile-row">
      <button id="mBtnRegen" type="button">é‡æ–°ç”¢ç”Ÿ</button>
      <button id="mBtnReset" type="button">é‡ç½®æœ¬é¡Œ</button>
    </div>

    <div class="keypad" aria-label="æ‰‹æ©Ÿæ•¸å­—é¢æ¿">
      <button data-k="1">1</button><button data-k="2">2</button><button data-k="3">3</button><button data-k="4">4</button><button data-k="5">5</button><button data-k="6">6</button>
      <button data-k="7">7</button><button data-k="8">8</button><button data-k="9">9</button>
      <button class="wide" data-act="hint">æç¤º 1 æ ¼</button>
      <button class="wide" data-act="solve">é¡¯ç¤ºç­”æ¡ˆ</button>
    </div>
  </section>

  <script>
    // ============ éŒ¯èª¤é¡¯ç¤ºï¼ˆé é¢ä¸Šç›´æ¥çœ‹åˆ°ï¼‰ ============
    const errbar = document.getElementById("errbar");
    function showErr(msg){
      errbar.classList.add("show");
      errbar.textContent = msg;
    }
    window.addEventListener("error", (e) => {
      showErr("âš ï¸ JS éŒ¯èª¤ï¼š\n" + (e?.error?.stack || e.message || String(e)));
    });
    window.addEventListener("unhandledrejection", (e) => {
      showErr("âš ï¸ Promise éŒ¯èª¤ï¼š\n" + (e?.reason?.stack || String(e.reason)));
    });

    // ============ æ‰‹æ©Ÿåˆ¤æ–·ï¼šUA + è§¸æ§ + è¢å¹• ============
    function detectMobile(){
      const ua = (navigator.userAgent || "").toLowerCase();
      const uaHit = /iphone|ipod|ipad|android|mobile|tablet/.test(ua);
      const coarse = window.matchMedia && window.matchMedia("(pointer: coarse)").matches;
      const small = window.matchMedia && window.matchMedia("(max-width: 1100px)").matches;
      return uaHit || (coarse && small);
    }

    const MOBILE = detectMobile();
    if (MOBILE) document.documentElement.classList.add("is-mobile");

    // ============ DOM ============
    const daysInput = document.getElementById("days");
    const cellSizeInput = document.getElementById("cellSize");
    const regenBtn = document.getElementById("regen");
    const daysWrap = document.getElementById("daysWrap");

    const activeLabel = document.getElementById("activeLabel");
    const sideStatus = document.getElementById("sideStatus");
    const btnNote = document.getElementById("btnNote");
    const btnWarn = document.getElementById("btnWarn");

    const mobileStatus = document.getElementById("mobileStatus");
    const mBtnNote = document.getElementById("mBtnNote");
    const mBtnWarn = document.getElementById("mBtnWarn");
    const mBtnClear = document.getElementById("mBtnClear");
    const mBtnRegen = document.getElementById("mBtnRegen");
    const mBtnReset = document.getElementById("mBtnReset");

    // ============ Sudoku ç”Ÿæˆ ============
    function makeSolvedGrid() {
      const base = 3, side = 9;
      const pattern = (r, c) => (base * (r % base) + Math.floor(r / base) + c) % side;

      const shuffle = (arr) => {
        const a = arr.slice();
        for (let i = a.length - 1; i > 0; i--) {
          const j = Math.floor(Math.random() * (i + 1));
          [a[i], a[j]] = [a[j], a[i]];
        }
        return a;
      };

      const rBase = [0,1,2];
      const rows  = shuffle(rBase).flatMap(g => shuffle(rBase).map(r => g*base + r));
      const cols  = shuffle(rBase).flatMap(g => shuffle(rBase).map(c => g*base + c));
      const nums  = shuffle([1,2,3,4,5,6,7,8,9]);

      const grid = [];
      for (let r = 0; r < side; r++) {
        const row = [];
        for (let c = 0; c < side; c++) row.push(nums[pattern(rows[r], cols[c])]);
        grid.push(row);
      }
      return grid;
    }

    function makePuzzleFromSolved(solved, clues) {
      const puzzle = solved.map(row => row.slice());
      const cells = [];
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) cells.push([r,c]);

      for (let i=cells.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [cells[i], cells[j]] = [cells[j], cells[i]];
      }

      const targetEmpties = 81 - clues;
      let removed = 0;
      for (const [r,c] of cells){
        if (removed >= targetEmpties) break;
        puzzle[r][c] = 0;
        removed++;
      }
      return puzzle;
    }

    function cluesByDay(dayIndex, totalDays) {
      const maxClues = 42, minClues = 24;
      if (totalDays <= 1) return maxClues;
      const t = dayIndex / (totalDays - 1);
      const clues = Math.round(maxClues + (minClues - maxClues) * t);
      return Math.max(minClues, Math.min(maxClues, clues));
    }

    function difficultyLabel(clues) {
      if (clues >= 38) return "Easy";
      if (clues >= 32) return "Easyâ†’Medium";
      if (clues >= 28) return "Medium";
      return "Mediumâ†’Hard";
    }

    // ============ è§£é¡Œå™¨ ============
    function cloneGrid(g){ return g.map(r => r.slice()); }

    function isValid(grid, r, c, val){
      for (let i=0;i<9;i++){
        if (grid[r][i] === val) return false;
        if (grid[i][c] === val) return false;
      }
      const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
      for (let rr=br; rr<br+3; rr++){
        for (let cc=bc; cc<bc+3; cc++){
          if (grid[rr][cc] === val) return false;
        }
      }
      return true;
    }

    function findEmpty(grid){
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (grid[r][c]===0) return [r,c];
      return null;
    }

    function solveOne(grid){
      const empty = findEmpty(grid);
      if (!empty) return true;
      const [r,c] = empty;

      const nums = [1,2,3,4,5,6,7,8,9];
      for (let i=nums.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [nums[i], nums[j]] = [nums[j], nums[i]];
      }

      for (const val of nums){
        if (isValid(grid, r, c, val)){
          grid[r][c] = val;
          if (solveOne(grid)) return true;
          grid[r][c] = 0;
        }
      }
      return false;
    }

    // ============ ç‹€æ…‹ ============
    const stateMap = new WeakMap();
    const keyRC = (r,c) => `${r},${c}`;
    let activeCard = null;

    function setGlobalStatus(text){
      sideStatus.textContent = text;
      mobileStatus.textContent = text;
    }
    function setActiveLabel(text){ activeLabel.textContent = text; }

    // âœ… å®Œæˆåµæ¸¬ï¼ˆä¸ä¾è³´éŒ¯èª¤è­¦å‘Šï¼‰
    function checkCompletion(card){
      const st = stateMap.get(card);
      if (!st || st.solvedShown || st.completed) return;

      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          if (st.current[r][c] === 0) return;
        }
      }
      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          if (st.original[r][c] !== 0) continue;
          if (st.current[r][c] !== st.solution[r][c]) return;
        }
      }

      st.completed = true;
      st.selected = null;
      card.classList.add("completed");
      setGlobalStatus("ğŸ‰ å®Œæˆï¼æœ¬é¡Œå·²æ­£ç¢ºè§£å‡ºï¼ˆå·²é–ç›¤ï¼Œå¯é‡ç½®ï¼‰");
      refreshAllCells(card);
    }

    function initState(card, puzzle, solution){
      stateMap.set(card, {
        original: cloneGrid(puzzle),
        current: cloneGrid(puzzle),
        solution: cloneGrid(solution),
        solvedShown: false,
        completed: false,
        noteMode: false,
        warnWrong: false,
        selected: null,
        notes: new Map()
      });
    }

    function syncToggleButtons(){
      if (!activeCard){
        btnNote.classList.remove("toggle-on");
        btnWarn.classList.remove("toggle-on");
        btnNote.textContent = "ç­†è¨˜ï¼šOFF";
        btnWarn.textContent = "éŒ¯èª¤è­¦å‘Šï¼šOFF";
        mBtnNote.classList.remove("toggle-on");
        mBtnWarn.classList.remove("toggle-on");
        mBtnNote.textContent = "ç­†è¨˜ï¼šOFF";
        mBtnWarn.textContent = "éŒ¯èª¤è­¦å‘Šï¼šOFF";
        return;
      }
      const st = stateMap.get(activeCard);
      btnNote.classList.toggle("toggle-on", st.noteMode);
      btnWarn.classList.toggle("toggle-on", st.warnWrong);
      btnNote.textContent = st.noteMode ? "ç­†è¨˜ï¼šON" : "ç­†è¨˜ï¼šOFF";
      btnWarn.textContent = st.warnWrong ? "éŒ¯èª¤è­¦å‘Šï¼šON" : "éŒ¯èª¤è­¦å‘Šï¼šOFF";

      mBtnNote.classList.toggle("toggle-on", st.noteMode);
      mBtnWarn.classList.toggle("toggle-on", st.warnWrong);
      mBtnNote.textContent = st.noteMode ? "ç­†è¨˜ï¼šON" : "ç­†è¨˜ï¼šOFF";
      mBtnWarn.textContent = st.warnWrong ? "éŒ¯èª¤è­¦å‘Šï¼šON" : "éŒ¯èª¤è­¦å‘Šï¼šOFF";
    }

    // ============ è¦–è¦ºæ¸²æŸ“ ============
    function renderNotes(cell, set){
      const old = cell.querySelector(".notes");
      if (old) old.remove();
      if (!set || set.size === 0) return;

      const notes = document.createElement("div");
      notes.className = "notes";
      for (let n=1;n<=9;n++){
        const sp = document.createElement("span");
        sp.textContent = set.has(n) ? String(n) : "";
        notes.appendChild(sp);
      }
      cell.appendChild(notes);
    }

    function countWrong(card){
      const st = stateMap.get(card);
      let wrong = 0;
      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          if (st.original[r][c] !== 0) continue;
          const v = st.current[r][c];
          if (v !== 0 && v !== st.solution[r][c]) wrong++;
        }
      }
      return wrong;
    }

    function countEmpties(card){
      const st = stateMap.get(card);
      let n=0;
      for (let r=0;r<9;r++) for (let c=0;c<9;c++) if (st.current[r][c]===0) n++;
      return n;
    }

    function applyCellVisual(card, cell, r, c){
      const st = stateMap.get(card);
      const v = st.current[r][c];
      const given = st.original[r][c] !== 0;

      cell.classList.remove("selected","user","wrong","solved");
      cell.textContent = "";

      if (given){
        cell.classList.add("given");
        cell.textContent = String(st.original[r][c]);
        renderNotes(cell, null);
        return;
      }

      if (st.solvedShown){
        cell.classList.add("solved");
        cell.textContent = String(st.solution[r][c]);
        renderNotes(cell, null);
        return;
      }

      if (v === 0){
        const nset = st.notes.get(keyRC(r,c));
        renderNotes(cell, nset);
      } else {
        cell.classList.add("user");
        cell.textContent = String(v);
        renderNotes(cell, null);

        if (st.warnWrong && v !== st.solution[r][c]){
          cell.classList.add("wrong");
        }
      }
    }

    function refreshAllCells(card){
      const cellEls = card.querySelectorAll(".cell");
      for (const cell of cellEls){
        const r = parseInt(cell.dataset.r,10);
        const c = parseInt(cell.dataset.c,10);
        applyCellVisual(card, cell, r, c);
      }
      const st = stateMap.get(card);
      if (st.selected){
        const sel = card.querySelector(`.cell[data-r="${st.selected.r}"][data-c="${st.selected.c}"]`);
        if (sel) sel.classList.add("selected");
      }
    }

    // ============ Active / é¸æ ¼ ============
    function setActiveCard(card){
      if (activeCard === card) return;
      document.querySelectorAll(".card.active").forEach(el => el.classList.remove("active"));
      activeCard = card;
      card.classList.add("active");

      const day = card.dataset.day;
      setActiveLabel(`Day ${day}`);
      syncToggleButtons();

      const st = stateMap.get(card);
      if (st.completed) setGlobalStatus("ğŸ‰ æœ¬é¡Œå·²å®Œæˆï¼ˆå·²é–ç›¤ï¼Œå¯é‡ç½®æˆ–é¡¯ç¤ºç­”æ¡ˆï¼‰");
      else if (st.solvedShown) setGlobalStatus("å·²é¡¯ç¤ºç­”æ¡ˆï¼ˆæŒ‰é‡ç½®å›åˆ°åŸé¡Œï¼‰");
      else if (!st.selected) setGlobalStatus("å·²é¸æ“‡é¡Œç›®ã€‚é»ä¸€å€‹ç©ºæ ¼é–‹å§‹ã€‚");
      else setGlobalStatus(st.noteMode ? "ç­†è¨˜æ¨¡å¼ï¼šé»æ•¸å­—åŠ å…¥/å–æ¶ˆå€™é¸" : "å¡«ç­”æ¨¡å¼ï¼šé»æ•¸å­—è¼¸å…¥");
    }

    function selectCell(card, r, c){
      setActiveCard(card);

      const st = stateMap.get(card);
      if (st.completed){ setGlobalStatus("æœ¬é¡Œå·²å®Œæˆï¼ˆå·²é–ç›¤ï¼‰ã€‚è¦å†æ”¹è«‹æŒ‰ã€Œé‡ç½®æœ¬é¡Œã€ã€‚"); return; }
      if (st.original[r][c] !== 0) return;
      if (st.solvedShown) return;

      st.selected = {r,c};
      card.querySelectorAll(".cell.selected").forEach(el => el.classList.remove("selected"));
      const cell = card.querySelector(`.cell[data-r="${r}"][data-c="${c}"]`);
      if (cell) cell.classList.add("selected");
      setGlobalStatus(st.noteMode ? "ç­†è¨˜æ¨¡å¼ï¼šé»æ•¸å­—åŠ å…¥/å–æ¶ˆå€™é¸" : "å¡«ç­”æ¨¡å¼ï¼šé»æ•¸å­—è¼¸å…¥");
    }

    // ============ å·¥å…·åˆ—æ“ä½œ ============
    function requireActive(){
      if (!activeCard){ setGlobalStatus("å…ˆé»ä»»ä¸€é¡Œçš„ç©ºæ ¼é–‹å§‹ã€‚"); return false; }
      return true;
    }

    function inputNumber(n){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      if (st.completed){ setGlobalStatus("æœ¬é¡Œå·²å®Œæˆï¼ˆå·²é–ç›¤ï¼‰ã€‚è¦å†æ”¹è«‹æŒ‰ã€Œé‡ç½®æœ¬é¡Œã€ã€‚"); return; }
      if (!st.selected){ setGlobalStatus("å…ˆé»é¸ä¸€å€‹ç©ºæ ¼ã€‚"); return; }
      if (st.solvedShown){ setGlobalStatus("å·²é¡¯ç¤ºç­”æ¡ˆï¼ˆæŒ‰é‡ç½®å›é¡Œç›®ï¼‰ã€‚"); return; }

      const {r,c} = st.selected;
      if (st.original[r][c] !== 0) return;

      if (st.noteMode){
        const k = keyRC(r,c);
        let set = st.notes.get(k);
        if (!set){ set = new Set(); st.notes.set(k, set); }
        if (set.has(n)) set.delete(n); else set.add(n);
      } else {
        st.current[r][c] = n;
        st.notes.delete(keyRC(r,c));
      }

      refreshAllCells(card);

      const wrong = countWrong(card);
      const left = countEmpties(card);

      if (st.noteMode){
        setGlobalStatus("å·²æ›´æ–°å€™é¸ï¼ˆç­†è¨˜æ¨¡å¼ï¼‰ã€‚");
      } else if (st.warnWrong){
        if (st.current[r][c] !== st.solution[r][c]) setGlobalStatus(`âŒ å¡«éŒ¯ï¼ˆéŒ¯èª¤æ ¼æ•¸ï¼š${wrong}ï¼‰`);
        else setGlobalStatus(`âœ… æ­£ç¢ºï¼å‰©é¤˜ç©ºæ ¼ï¼š${left}ï¼ˆéŒ¯èª¤æ ¼æ•¸ï¼š${wrong}ï¼‰`);
      } else {
        setGlobalStatus(`å·²å¡«å…¥ã€‚å‰©é¤˜ç©ºæ ¼ï¼š${left}`);
      }

      checkCompletion(card);
    }

    function clearSelected(){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      if (st.completed){ setGlobalStatus("æœ¬é¡Œå·²å®Œæˆï¼ˆå·²é–ç›¤ï¼‰ã€‚è¦å†æ”¹è«‹æŒ‰ã€Œé‡ç½®æœ¬é¡Œã€ã€‚"); return; }
      if (!st.selected){ setGlobalStatus("å…ˆé»é¸ä¸€å€‹ç©ºæ ¼ã€‚"); return; }
      if (st.solvedShown){ setGlobalStatus("å·²é¡¯ç¤ºç­”æ¡ˆï¼ˆæŒ‰é‡ç½®å›é¡Œç›®ï¼‰ã€‚"); return; }

      const {r,c} = st.selected;
      if (st.original[r][c] !== 0) return;

      if (st.noteMode){
        st.notes.delete(keyRC(r,c));
      } else {
        st.current[r][c] = 0;
        st.notes.delete(keyRC(r,c));
      }

      refreshAllCells(card);
      setGlobalStatus("å·²æ¸…é™¤ã€‚");
      checkCompletion(card);
    }

    function giveHint(){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      if (st.completed){ setGlobalStatus("æœ¬é¡Œå·²å®Œæˆï¼ˆå·²é–ç›¤ï¼‰ã€‚"); return; }
      if (st.solvedShown){ setGlobalStatus("å·²é¡¯ç¤ºç­”æ¡ˆï¼ˆæŒ‰é‡ç½®å›é¡Œç›®ï¼‰ã€‚"); return; }

      let done = false;
      for (let r=0;r<9 && !done;r++){
        for (let c=0;c<9 && !done;c++){
          if (st.original[r][c] === 0 && st.current[r][c] === 0){
            st.current[r][c] = st.solution[r][c];
            st.notes.delete(keyRC(r,c));
            st.selected = {r,c};
            done = true;
          }
        }
      }

      refreshAllCells(card);

      if (!done){
        setGlobalStatus("æœ¬é¡Œå·²å¡«æ»¿ âœ…");
        checkCompletion(card);
        return;
      }

      const left = countEmpties(card);
      const wrong = countWrong(card);
      setGlobalStatus(st.warnWrong ? `æç¤º 1 æ ¼ âœ… å‰©é¤˜ç©ºæ ¼ï¼š${left}ï¼ˆéŒ¯èª¤æ ¼æ•¸ï¼š${wrong}ï¼‰` : `æç¤º 1 æ ¼ âœ… å‰©é¤˜ç©ºæ ¼ï¼š${left}`);
      checkCompletion(card);
    }

    function revealSolution(){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      st.solvedShown = true;
      st.selected = null;
      st.completed = false;
      card.classList.remove("completed");

      refreshAllCells(card);
      setGlobalStatus("å·²é¡¯ç¤ºç­”æ¡ˆ âœ…ï¼ˆæŒ‰é‡ç½®å¯å›åˆ°åŸé¡Œï¼‰");
    }

    function resetPuzzle(){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      st.current = cloneGrid(st.original);
      st.notes.clear();
      st.solvedShown = false;
      st.selected = null;

      st.completed = false;
      card.classList.remove("completed");

      refreshAllCells(card);
      setGlobalStatus("å·²é‡ç½®ç‚ºåŸé¡Œã€‚");

      fitBoardToScreen();
    }

    function toggleNote(){
      if (!requireActive()) return;
      const st = stateMap.get(activeCard);
      st.noteMode = !st.noteMode;
      syncToggleButtons();
      setGlobalStatus(st.noteMode ? "ç­†è¨˜æ¨¡å¼ï¼šé»æ•¸å­—åŠ å…¥/å–æ¶ˆå€™é¸" : "å¡«ç­”æ¨¡å¼ï¼šé»æ•¸å­—è¼¸å…¥");
    }

    function toggleWarn(){
      if (!requireActive()) return;
      const card = activeCard;
      const st = stateMap.get(card);

      st.warnWrong = !st.warnWrong;
      syncToggleButtons();
      refreshAllCells(card);

      if (st.warnWrong){
        const wrong = countWrong(card);
        setGlobalStatus(wrong > 0 ? `å·²é–‹å•ŸéŒ¯èª¤è­¦å‘Šï¼šç›®å‰éŒ¯èª¤æ ¼æ•¸ ${wrong}` : "å·²é–‹å•ŸéŒ¯èª¤è­¦å‘Šï¼šç›®å‰æ²’æœ‰éŒ¯èª¤");
      } else {
        setGlobalStatus("å·²é—œé–‰éŒ¯èª¤è­¦å‘Šï¼ˆä¸å†æ¨™ç´…ï¼‰ã€‚");
      }

      checkCompletion(card);
    }

    // âœ… æ‰‹æ©Ÿç›¤é¢è‡ªå‹•ã€Œèª¿æ•´ --cellã€å¡é€²è¢å¹•
    function fitBoardToScreen(){
      if (!MOBILE) return;

      const card = document.querySelector(".card");
      if (!card) return;

      // æ‰‹æ©Ÿä¸Šæ²’æœ‰ç´…è‰²è¨­å®šå€ï¼Œä½† input ä»å­˜åœ¨ï¼ˆåªæ˜¯ display:noneï¼‰
      const userCell = Math.max(28, Math.min(64, parseInt(cellSizeInput.value || "44", 10)));

      const cs = getComputedStyle(card);
      const padL = parseFloat(cs.paddingLeft) || 0;
      const padR = parseFloat(cs.paddingRight) || 0;
      const avail = card.clientWidth - padL - padR;

      const root = getComputedStyle(document.documentElement);
      const thick = parseFloat(root.getPropertyValue("--thick")) || 3;

      const usableForCells = Math.max(0, avail - thick * 2);
      const fitCell = Math.floor(usableForCells / 9);

      const finalCell = Math.max(28, Math.min(userCell, fitCell));
      document.documentElement.style.setProperty("--cell", `${finalCell}px`);
    }

    // ============ æ¸²æŸ“ä¸€é¡Œ ============
    function renderPuzzleCard(dayNumber, puzzle, solution, clues) {
      const card = document.createElement("article");
      card.className = "card";
      card.dataset.day = String(dayNumber);

      initState(card, puzzle, solution);

      const h2 = document.createElement("h2");
      h2.innerHTML = `Day ${dayNumber} <span class="badge">${difficultyLabel(clues)} Â· clues ${clues}</span>`;
      card.appendChild(h2);

      const gridEl = document.createElement("div");
      gridEl.className = "sudoku";
      gridEl.setAttribute("aria-label", `Sudoku Day ${dayNumber}`);

      for (let r=0;r<9;r++){
        for (let c=0;c<9;c++){
          const cell = document.createElement("div");
          cell.className = "cell";
          cell.tabIndex = 0;
          cell.dataset.r = String(r);
          cell.dataset.c = String(c);

          if (c === 2 || c === 5) cell.classList.add("thick-r");
          if (r === 2 || r === 5) cell.classList.add("thick-b");
          if (c === 8) cell.classList.add("last-col");
          if (r === 8) cell.classList.add("last-row");

          cell.addEventListener("click", () => selectCell(card, r, c));
          cell.addEventListener("keydown", (e) => {
            if (e.key === "Enter" || e.key === " ") selectCell(card, r, c);
          });

          gridEl.appendChild(cell);
        }
      }

      const wrap = document.createElement("div");
      wrap.className = "board-wrap";
      wrap.appendChild(gridEl);
      card.appendChild(wrap);

      const divider = document.createElement("div");
      divider.className = "divider";
      card.appendChild(divider);

      refreshAllCells(card);

      card.addEventListener("click", () => setActiveCard(card));
      return card;
    }

    // ============ ç”¢ç”Ÿå…¨éƒ¨ ============
    function generateAll() {
      const totalDays = MOBILE
        ? 1
        : Math.max(1, Math.min(60, parseInt(daysInput.value || "30", 10)));

      const cellSize = Math.max(28, Math.min(64, parseInt(cellSizeInput.value || "44", 10)));
      document.documentElement.style.setProperty("--cell", `${cellSize}px`);

      daysWrap.innerHTML = "";
      activeCard = null;
      setActiveLabel("å°šæœªé¸é¡Œ");
      setGlobalStatus("å…ˆé»ä»»ä¸€é¡Œçš„ç©ºæ ¼é–‹å§‹ã€‚");
      syncToggleButtons();

      for (let i = 0; i < totalDays; i++) {
        const clues = cluesByDay(i, totalDays);

        const solved = makeSolvedGrid();
        const puzzle = makePuzzleFromSolved(solved, clues);

        const toSolve = cloneGrid(puzzle);
        const ok = solveOne(toSolve);
        const solution = ok ? toSolve : solved;

        daysWrap.appendChild(renderPuzzleCard(i + 1, puzzle, solution, clues));
      }

      if (MOBILE){
        daysInput.value = 1;
        daysInput.disabled = true;
      } else {
        daysInput.disabled = false;
      }

      fitBoardToScreen();
      requestAnimationFrame(() => fitBoardToScreen());
    }

    // ============ ç¶äº‹ä»¶ ============
    function safeBind(fn){
      try { fn(); } catch (e) { showErr("âš ï¸ åˆå§‹åŒ–ç¶å®šå¤±æ•—ï¼š\n" + (e?.stack || String(e))); }
    }

    safeBind(() => {
      // æ¡Œæ©Ÿ
      btnNote.addEventListener("click", toggleNote);
      btnWarn.addEventListener("click", toggleWarn);

      const sideKeypad = document.querySelector(".sidebar .keypad");
      const sideActions = document.querySelector(".sidebar .actions");
      if (sideKeypad){
        sideKeypad.addEventListener("click", (e) => {
          const b = e.target.closest("button");
          if (!b) return;
          const k = b.getAttribute("data-k");
          const act = b.getAttribute("data-act");
          if (k) inputNumber(parseInt(k, 10));
          if (act === "clear") clearSelected();
          if (act === "hint") giveHint();
        });
      }
      if (sideActions){
        sideActions.addEventListener("click", (e) => {
          const b = e.target.closest("button");
          if (!b) return;
          const act = b.getAttribute("data-act");
          if (act === "solve") revealSolution();
          if (act === "reset") resetPuzzle();
        });
      }

      // æ‰‹æ©Ÿ
      mBtnNote.addEventListener("click", toggleNote);
      mBtnWarn.addEventListener("click", toggleWarn);
      mBtnClear.addEventListener("click", clearSelected);

      // âœ… è—è‰²å€å¡Šï¼šé‡æ–°ç”¢ç”Ÿ
      mBtnRegen.addEventListener("click", () => {
        generateAll();
        setGlobalStatus("å·²é‡æ–°ç”¢ç”Ÿæ–°é¡Œç›® âœ…");
      });

      // âœ… è—è‰²å€å¡Šï¼šé‡ç½®æœ¬é¡Œ
      mBtnReset.addEventListener("click", resetPuzzle);

      const mobKeypad = document.querySelector(".mobilebar .keypad");
      if (mobKeypad){
        mobKeypad.addEventListener("click", (e) => {
          const b = e.target.closest("button");
          if (!b) return;
          const k = b.getAttribute("data-k");
          const act = b.getAttribute("data-act");
          if (k) inputNumber(parseInt(k, 10));
          if (act === "hint") giveHint();
          if (act === "solve") revealSolution();
        });
      }

      // æ¡Œæ©Ÿä¸Šæ–¹é‡æ–°ç”¢ç”Ÿä»ä¿ç•™
      regenBtn.addEventListener("click", generateAll);
      daysInput.addEventListener("change", generateAll);
      cellSizeInput.addEventListener("change", generateAll);

      window.addEventListener("resize", () => {
        fitBoardToScreen();
        requestAnimationFrame(() => fitBoardToScreen());
      });
    });

    // åˆæ¬¡è¼‰å…¥
    try { generateAll(); } catch (e) { showErr("âš ï¸ ç”¢ç”Ÿé¡Œç›®å¤±æ•—ï¼š\n" + (e?.stack || String(e))); }
  </script>
</body>
</html>
